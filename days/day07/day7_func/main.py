"""
main program for solving puzzle 1 & 2 of day 7
"""

from get_inp import convert_data_for_puzzle_one, get_folder_from_path


def puzzle_one_sol_rec() -> int:
    """
    finds the directorys generated by the input data with less than 100.000
    bytes of size recursive and adds them up

    Returns:
        int: sum of all directorys with size less than 100.000
    """
    data: list[...] = convert_data_for_puzzle_one()

    size_dict: dict[str, int] = {}

    def get_size(address: list[int]) -> int:
        if size_dict.get(str(address)):
            return size_dict.get(str(address))
        size: int = 0
        for idx, it in enumerate(get_folder_from_path(data, address)):
            if type(it) is int:
                size += it
            else:
                size += get_size(address + [idx])
        size_dict[str(address)] = size
        return size

    def get_sum_of_directorys_with_max_size_from_dir_at(address: list[int], max_size: int) -> int:
        if get_size(address) < max_size:
            return get_size(address) + sum(
                [get_sum_of_directorys_with_max_size_from_dir_at(address + [idx], max_size)
                    for idx, it in enumerate(get_folder_from_path(data, address)) if type(it) is list]
            )
        return sum(
            [get_sum_of_directorys_with_max_size_from_dir_at(address + [idx], max_size)
             for idx, it in enumerate(get_folder_from_path(data, address)) if type(it) is list]
        )

    data: list[...] = convert_data_for_puzzle_one()
    return get_sum_of_directorys_with_max_size_from_dir_at([], 100_000)


def puzzle_one_sol_it() -> int:
    """
    finds the directorys generated by the input data with less than 100.000
    bytes of size iterative and adds them up

    Returns:
        int: sum of all directorys with size less than 100.000
    """
    data: list[...] = convert_data_for_puzzle_one()
    # maps directory-addresses to their sizes
    directory_sizes: dict[str, int] = {'[]': 0}
    sum_of_directorys: int = 0
    address_stack: list[list[int]] = [[]]
    while len(address_stack):
        current_address: list[int] = address_stack.pop(-1)
        current_dir: list[...] = get_folder_from_path(data, current_address)
        size_of_current_dir: int = 0
        if directory_sizes.get(str(current_address)):
            # coming back to folder bcs subfolders needed to be calculated first
            # subfolders already added their size to the size of their parent folder
            # -> size is just the sum of the subfolders and the files in the folder
            size_of_current_dir = directory_sizes.get(str(current_address)) + sum(
                [item for item in current_dir if type(item) is int]
            )
        else:  # default
            if all([type(item) is int for item in current_dir]):  # all items in folder are files
                # size of folder is just sum of files
                size_of_current_dir = sum(current_dir)
            else:
                # folder consists of files and subfolders -> calculate subfolders first (1)
                #                       and come back to calculating the size afterwards (2)
                # push 'coming back' on stack first (2) -> gets executed second
                address_stack.append(current_address)
                # calculate subfolders first (1)
                address_stack.extend([current_address + [idx] for idx,
                                      item in enumerate(current_dir) if type(item) is list])

        directory_sizes[str(current_address)] = size_of_current_dir
        if len(address_stack):
            # if you're not root -> add your size to parent-folder
            directory_sizes[str(current_address[:-1])] += size_of_current_dir

        if size_of_current_dir and size_of_current_dir < 100_000:
            sum_of_directorys += size_of_current_dir
    return sum_of_directorys


def puzzle_two_sol() -> int:
    """
    finds the directorys generated by the input data that, when deleted, frees
    as close to(but at least) 30_000_000 bytes of storage as possible

    Returns:
        int: size of the best found directory
    """
    data: list[...] = convert_data_for_puzzle_one()
    directory_sizes: dict[str, int] = {'[]': 0}
    address_stack: list[list[int]] = [[]]
    while len(address_stack):
        current_address: list[int] = address_stack.pop(-1)
        current_dir: list[...] = get_folder_from_path(data, current_address)
        size_of_current_dir: int = 0
        if directory_sizes.get(str(current_address)):
            size_of_current_dir = directory_sizes.get(str(current_address)) + sum(
                [item for item in current_dir if type(item) is int]
            )
        else:
            if all([type(item) is int for item in current_dir]):
                size_of_current_dir = sum(current_dir)
            else:
                address_stack.append(current_address)
                address_stack.extend([current_address + [idx] for idx,
                                      item in enumerate(current_dir) if type(item) is list])
        directory_sizes[str(current_address)] = size_of_current_dir
        if len(address_stack):
            directory_sizes[str(current_address[:-1])] += size_of_current_dir
    needed_space: int = 30_000_000 + directory_sizes.get('[]') - 70_000_000
    best_found_size: int = directory_sizes.get('[]')
    for size in directory_sizes.values():
        if size > needed_space and size < best_found_size:
            best_found_size = size
    return best_found_size


def main() -> None:
    """
    Function for testing purposes
    """
    print(puzzle_one_sol_rec())
    print(puzzle_one_sol_it())
    print(puzzle_two_sol())


if __name__ == '__main__':
    main()
