"""
main program for solving puzzle 1 & 2 of day 7
"""

from get_inp import Directory, convert_data_for_puzzle_one


def puzzle_one_sol_rec() -> int:
    """
    finds the directorys generated by the input data with less than 100.000
    bytes of size recursive and adds them up

    Returns:
        int: sum of all directorys with size less than 100.000
    """
    def get_sum_of_directorys_with_max_size_and_root_directory(root: Directory, max_size: int) -> int:
        if root.get_size() < max_size:
            return root.get_size() + sum([get_sum_of_directorys_with_max_size_and_root_directory(dir, max_size) for dir in root.get_all_subfolder()])
        return sum([get_sum_of_directorys_with_max_size_and_root_directory(dir, max_size) for dir in root.get_all_subfolder()])

    return get_sum_of_directorys_with_max_size_and_root_directory(convert_data_for_puzzle_one(), 100_000)


def puzzle_one_sol_it() -> int:
    """
    finds the directorys generated by the input data with less than 100.000
    bytes of size iterative and adds them up

    Returns:
        int: sum of all directorys with size less than 100.000
    """
    # default iterative stack-conversion of the recursive solution
    sum_of_directorys: int = 0
    dir_stack: list[Directory] = [convert_data_for_puzzle_one()]
    while len(dir_stack):
        current_dir: Directory = dir_stack.pop(-1)
        size_of_current_dir: int = current_dir.get_size()
        if size_of_current_dir < 100_000:
            sum_of_directorys += size_of_current_dir
        dir_stack.extend(current_dir.get_all_subfolder())
    return sum_of_directorys


def puzzle_two_sol() -> int:
    """
    finds the directorys generated by the input data that, when deleted, frees
    as close to (but at least) 30_000_000 bytes of storage as possible

    Returns:
        int: size of the best found directory
    """
    root_directory: Directory = convert_data_for_puzzle_one()
    needed_space: int = 30_000_000 + root_directory.get_size() - 70_000_000
    best_found_size: int = 70_000_000
    dir_stack: list[Directory] = [root_directory]
    while len(dir_stack):
        current_dir: Directory = dir_stack.pop(-1)
        size_of_current_dir: int = current_dir.get_size()
        if size_of_current_dir > needed_space:
            if best_found_size > size_of_current_dir:
                best_found_size = size_of_current_dir
            dir_stack.extend(current_dir.get_all_subfolder())
    return best_found_size


def main() -> None:
    """
    Function for testing purposes
    """
    print(puzzle_one_sol_rec())
    print(puzzle_one_sol_it())
    print(puzzle_two_sol())


if __name__ == '__main__':
    main()
